{"name":"Baum","tagline":"Baum is an implementation of the Nested Set pattern for Laravel 4's Eloquent ORM.","body":"# Baum\r\n\r\nBaum is an implementation of the [Nested Set](http://en.wikipedia.org/wiki/Nested_set_model)\r\npattern for [Laravel 4's](http://laravel.com/) Eloquent ORM.\r\n\r\n## Documentation\r\n\r\n* [About Nested Sets](#about)\r\n* [The theory behind, a TL;DR version](#theory)\r\n* [Installation](#installation)\r\n* [Getting started](#getting-started)\r\n* [Usage](#usage)\r\n\r\n<a name=\"about\"></a>\r\n## About Nested Sets\r\n\r\nA nested set is a smart way to implement an _ordered_ tree that allows for fast,\r\nnon-recursive queries. For example, you can fetch all descendants of a node in a\r\nsingle query, no matter how deep the tree. The drawback is that insertions/moves/deletes\r\nrequire complex SQL, but that is handled behind the curtains by this package!\r\n\r\nNested sets are appropriate for ordered trees (e.g. menus, commercial categories)\r\nand big trees that must be queried efficiently (e.g. threaded posts).\r\n\r\nSee the [wikipedia entry for nested sets](http://en.wikipedia.org/wiki/Nested_set_model)\r\nfor more info. Also, this is a good introductory tutorial:\r\n[http://www.evanpetersen.com/item/nested-sets.html](http://www.evanpetersen.com/item/nested-sets.html)\r\n\r\n<a name=\"theory\"></a>\r\n## The theory behind, a TL;DR version\r\n\r\nAn easy way to visualize how a nested set works is to think of a parent entity surrounding all\r\nof its children, and its parent surrounding it, etc. So this tree:\r\n\r\n    root\r\n      |_ Child 1\r\n        |_ Child 1.1\r\n        |_ Child 1.2\r\n      |_ Child 2\r\n        |_ Child 2.1\r\n        |_ Child 2.2\r\n\r\n\r\nCould be visualized like this:\r\n\r\n     ___________________________________________________________________\r\n    |  Root                                                             |\r\n    |    ____________________________    ____________________________   |\r\n    |   |  Child 1                  |   |  Child 2                  |   |\r\n    |   |   __________   _________  |   |   __________   _________  |   |\r\n    |   |  |  C 1.1  |  |  C 1.2 |  |   |  |  C 2.1  |  |  C 2.2 |  |   |\r\n    1   2  3_________4  5________6  7   8  9_________10 11_______12 13  14\r\n    |   |___________________________|   |___________________________|   |\r\n    |___________________________________________________________________|\r\n\r\nThe numbers represent the left and right boundaries.  The table then might\r\nlook like this:\r\n\r\n    id | parent_id | lft  | rgt  | depth | data\r\n     1 |           |    1 |   14 |     0 |root\r\n     2 |         1 |    2 |    7 |     1 | Child 1\r\n     3 |         2 |    3 |    4 |     2 | Child 1.1\r\n     4 |         2 |    5 |    6 |     2 | Child 1.2\r\n     5 |         1 |    8 |   13 |     1 | Child 2\r\n     6 |         5 |    9 |   10 |     2 | Child 2.1\r\n     7 |         5 |   11 |   12 |     2 | Child 2.2\r\n\r\nTo get all children of a _parent_ node, you\r\n\r\n    SELECT * WHERE lft IS BETWEEN parent.lft AND parent.rgt\r\n\r\nTo get the number of children, it's\r\n\r\n    (right - left - 1)/2\r\n\r\nTo get a node and all its ancestors going back to the root, you\r\n\r\n    SELECT * WHERE node.lft IS BETWEEN lft AND rgt\r\n\r\nAs you can see, queries that would be recursive and prohibitively slow on\r\nordinary trees are suddenly quite fast. Nifty, isn't it?\r\n\r\n<a name=\"installation\"></a>\r\n## Installation\r\n\r\nBaum works with Laravel 4 beta 4 and, hopefully, onwards. You can add it to your\r\n`composer.json` file with:\r\n\r\n    \"baum/baum\": \"~1.0\"\r\n\r\nRun `composer install` to install it.\r\n\r\nAs with most Laravel 4 packages you'll then need to register the Baum\r\n*service provider*. To do that, head over your `app/config/app.php` file and add\r\nthe following line into the `providers` array:\r\n\r\n    'Baum\\BaumServiceProvider',\r\n\r\n<a name=\"getting-started\"></a>\r\n## Getting started\r\n\r\nAfter the package is correctly installed the easiest way to get started is to\r\nrun the provided generator:\r\n\r\n    php artisan baum:install MODEL\r\n\r\nReplace model by the class name you plan to use for your Nested Set model.\r\n\r\nThe generator will install a migration and a model file into your application\r\nconfigured to work with the Nested Set behaviour provided by Baum. You SHOULD\r\ntake a look at those files, as each of them describes how they can be customized.\r\n\r\nNext, you would probably run `artisan migrate` to apply the migration.\r\n\r\n### Model configuration\r\n\r\nIn order to work with Baum, you must ensure that your model class extends\r\n`Baum\\Node`.\r\n\r\nThis is the easiest it can get:\r\n\r\n    <?php\r\n\r\n    class Category extends Baum\\Node {\r\n\r\n    }\r\n\r\nThis is a *slightly* more complex example where we have the column names customized:\r\n\r\n    <?php\r\n\r\n    class Dictionary extends Baum\\Node {\r\n\r\n      protected $table = 'dictionary';\r\n\r\n      // 'parent_id' column name\r\n      protected $parentColumn = 'parent_id';\r\n\r\n      // 'lft' column name\r\n      protected $leftColumn = 'lidx';\r\n\r\n      // 'rgt' column name\r\n      protected $rightColumn = 'ridx';\r\n\r\n      // 'depth' column name\r\n      protected $depthColumn = 'nesting';\r\n\r\n      // guard attributes from mass-assignment\r\n      protected $guarded = array('id', 'parent_id', 'lidx', 'ridx', 'nesting');\r\n\r\n    }\r\n\r\nRemember that, obviously, the column names must match those in the database table.\r\n\r\n### Migration configuration\r\n\r\nYou must ensure that the database table that supports your Baum models has the\r\nfollowing columns:\r\n\r\n* `parent_id`: a reference to the parent (int)\r\n* `lft`: left index bound (int)\r\n* `rgt`: right index bound (int)\r\n* `depth`: depth or nesting level (int)\r\n\r\nHere is a sample migration file:\r\n\r\n    <?php\r\n\r\n    class Category extends Migration {\r\n\r\n      public function up() {\r\n        Schema::create('categories', function(Blueprint $table) {\r\n          $table->increments('id');\r\n\r\n          $table->integer('parent_id')->nullable();\r\n          $table->integer('lft')->nullable();\r\n          $table->integer('rgt')->nullable();\r\n          $table->integer('depth')->nullable();\r\n\r\n          $table->string('name', 255);\r\n\r\n          $table->timestamps();\r\n        });\r\n      }\r\n\r\n      public function down() {\r\n        Schema::drop('categories');\r\n      }\r\n\r\n    }\r\n\r\nYou may freely modify the column names, provided you change them both in the\r\nmigration and the model.\r\n\r\n<a name=\"usage\"></a>\r\n## Usage\r\n\r\nAfter you've configured your model and run the migration, you are now ready\r\nto use Baum with your model. Below are some examples.\r\n\r\n* [Creating a root node](#creating-root-node)\r\n* [Inserting nodes](#inserting-nodes)\r\n* [Deleting nodes](#deleting-nodes)\r\n* [Getting the nesting level of a node](#node-level)\r\n* [Moving nodes around](#moving-nodes)\r\n* [Asking questions to your nodes](#node-questions)\r\n* [Relations](#node-relations)\r\n* [Root and Leaf scopes](#node-basic-scopes)\r\n* [Accessing the ancestry/descendancy chain](#node-chains)\r\n* [Model events: `moving` and `moved`](#node-model-events)\r\n\r\n<a name=\"creating-root-node\"></a>\r\n### Creating a root node\r\n\r\nBy default, all nodes are created as roots:\r\n\r\n    $root = Category::crete(['name' => 'Root category']);\r\n\r\nAlternatively, you may find yourself in the need of *converting* an existing node\r\ninto a *root node*:\r\n\r\n    $node->makeRoot();\r\n\r\n<a name=\"inserting-nodes\"></a>\r\n### Inserting nodes\r\n\r\n    // Directly with a relation\r\n    $child1 = $root->children()->create(['name' => 'Child 1']);\r\n\r\n    // with the `makeChildOf` method\r\n    $child2 = Category::create(['name' => 'Child 2']);\r\n    $child2->makeChildOf($root);\r\n\r\n<a name=\"deleting-nodes\"></a>\r\n### Deleting nodes\r\n\r\n    $child1->delete();\r\n\r\nDescendants of deleted nodes will also be deleted and all the `lft` and `rgt`\r\nbound will be recalculated. Pleases note that, for now, `deleting` and `deleted`\r\nmodel events for the descendants will not be fired.\r\n\r\n<a name=\"node-level\"></a>\r\n### Getting the nesting level of a node\r\n\r\nThe `getLevel()` method will return current nesting level, or depth, of a node.\r\n\r\n    $node->getLevel() // 0 when root\r\n\r\n<a name=\"moving-nodes\"></a>\r\n### Moving nodes around\r\n\r\nBaum provides several methods for moving nodes around:\r\n\r\n* `moveLeft()`: Find the left sibling and move to left of it.\r\n* `moveRight()`: Find the right sibling and move to the right of it.\r\n* `moveToLeftOf($otherNode)`: Move to the node to the left of ...\r\n* `moveToRightOf($otherNode)`: Move to the node to the right of ...\r\n* `makeNextSiblingOf($otherNode)`: Alias for `moveToRightOf`.\r\n* `makeSiblingOf($otherNode)`: Alias for `makeNextSiblingOf`.\r\n* `makePreviousSiblingOf($otherNode)`: Alias for `moveToLeftOf`.\r\n* `makeChildOf($otherNode)`: Make the node a child of ...\r\n* `makeRoot()`: Make current node a root node.\r\n\r\nFor example:\r\n\r\n    $root = Creatures::create(['name' => 'The Root of All Evil']);\r\n\r\n    $dragons = Creatures::create(['name' => 'Here Be Dragons']);\r\n    $dragons->makeChildOf($root);\r\n\r\n    $monsters = new Creatures(['name' => 'Horrible Monsters']);\r\n    $monsters->save();\r\n\r\n    $monsters-makeSiblingOf($dragons);\r\n\r\n    $demons = Creatures::where('name', '=', 'demons');\r\n    $demons->moveToLeftOf($dragons);\r\n\r\n<a name=\"node-questions\"></a>\r\n### Asking questions to your nodes\r\n\r\nYou can ask some questions to your Baum nodes:\r\n\r\n* `isRoot()`: Returns true if this is a root node.\r\n* `isLeaf()`: Returns true if this is a leaf node (end of a branch).\r\n* `isChild()`: Returns true if this is a child node.\r\n* `isDescendantOf($other)`: Returns true if node is a descendant of the other.\r\n* `isSelfOrDescendantOf($other)`: Returns true if node is self or a descendant.\r\n* `isAncestorOf($other)`: Returns true if node is an ancestor of the other.\r\n* `isSelfOrAncestorOf($other)`: Returns true if node is self or an ancestor.\r\n* `equals($node)`: current node instance equals the other.\r\n* `insideSubtree($node)`: Checks wether the given node is inside the subtree\r\ndefined by the left and right indices.\r\n\r\nUsing the nodes from the previous example:\r\n\r\n    $demons->isRoot(); // => false\r\n\r\n    $demons->isDescendantOf($root) // => true\r\n\r\n<a name=\"node-relations\"></a>\r\n### Relations\r\n\r\nBaum provides two self-referential Eloquent relations for your nodes: `parent`\r\nand `children`.\r\n\r\n    $parent = $node->parent()->get();\r\n\r\n    $children = $node->children()->get();\r\n\r\n<a name=\"node-basic-scopes\"></a>\r\n### Root and Leaf scopes\r\n\r\nBaum provides some very basic query scopes for accessing the root and leaf nodes:\r\n\r\n    // Query scope which targets all root nodes\r\n    Category::roots()\r\n\r\n    // All leaf nodes (nodes at the end of a branch)\r\n    Category:allLeaves()\r\n\r\nYou may also be interested in only the first root:\r\n\r\n    $firstRootNode = Category::root();\r\n\r\n<a name=\"node-chains\"></a>\r\n### Accessing the ancestry/descendancy chain\r\n\r\nThere are several methods which Baum offers to access the ancestry/desncendancy\r\nchain of a node in the Nested Set tree. The main thing to keep in mind is that\r\nthey are provided in two ways:\r\n\r\nFirst as **query scopes**, returning an `Illuminate\\Database\\Eloquent\\Builder`\r\ninstance to continue to query further. To get *actual* results from these,\r\nremember to call `get()` or `first()`.\r\n\r\n* `ancestorsAndSelf()`: Targets all the ancestor chain nodes including the current one.\r\n* `ancestors()`: Query the ancestor chain nodes excluding the current one.\r\n* `siblingsAndSelf()`: Instance scope which targets all children of the parent, including self.\r\n* `siblings()`: Instance scope targeting all children of the parent, except self.\r\n* `leaves()`: Instance scope targeting all of its nested children which do not have children.\r\n* `descendantsAndSelf()`: Scope targeting itself and all of its nested children.\r\n* `descendants()`: Set of all children & nested children.\r\n\r\nSecond, as **methods** which return actual `Baum\\Node` instances.\r\n\r\n* `getRoot()`: Returns the root node starting at the current node.\r\n* `getAncestorsAndSelf()`: Retrieve all the ancestor chain including the current node.\r\n* `getAncestors()`: Get all the ancestor chain from the database excluding the current node.\r\n* `getSiblingsAndSelf()`: Get all children of the parent, including self.\r\n* `getSiblings()`: Return all children of the parent, except self.\r\n* `getLeaves()`: Return all of its nested children which do not have children.\r\n* `getDescendantsAndSelf()`: Retrieve all nested children an self.\r\n* `getDescendants()`: Retrieve all of its children & nested children.\r\n\r\nHere's a simple example for iterating a node's descendants (provided a name\r\nattribute is available):\r\n\r\n    $node = Category::where('name', '=', 'Books');\r\n\r\n    foreach($node->getDescendantsAndSelf() as $descendants) {\r\n      echo \"{$node->name}\";\r\n    }\r\n\r\n<a name=\"node-model-events\"></a>\r\n### Model events: `moving` and `moved`\r\n\r\nBaum models fire the following events: `moving` and `moved` every time a node\r\nis *moved* around the Nested Set tree. This allows you to hook into those points\r\nin the node movement process. As with normal Eloquent model events, if `false`\r\nis returned from the `moving` event, the movement operation will be cancelled.\r\n\r\nThe recommended way to hook into those events is by using the model's boot\r\nmethod:\r\n\r\n    class Category extends Baum\\Node {\r\n\r\n      public static function boot() {\r\n        parent::boot();\r\n\r\n        static::moving(function($node) {\r\n          // Before moving the node this function will be called.\r\n        });\r\n\r\n        static::moved(function($node) {\r\n          // After the move operation is processed this function will be\r\n          // called.\r\n        });\r\n      }\r\n\r\n    }\r\n\r\n## TODO\r\n\r\nSome things I'm probably adding to this library (soonish, I hope):\r\n\r\n1. Scoping support. As of now, there's no scoping involved in Baum's queries.\r\nIntroducing scoping support, and some way to configure it, will allow us\r\nto have various Nested Set models in the same database table.\r\n2. Rebuild from other implementations. You've got a current model & table,\r\nwith only a `parent_id` id column? Shouldn't be a problem. Should it?\r\n\r\n## Contributing\r\n\r\nThinking of contributing? Maybe you've found some nasty bug? That's great news!\r\n\r\n1. Fork the project:.\r\n2. Create your bugfix/feature branch.\r\n3. Commit your changes & push to the branch.\r\n4. Create new Pull Request\r\n\r\n## License\r\n\r\nBaum is licensed under the terms of the [MIT License](http://opensource.org/licenses/MIT)\r\n(See LICENSE file for details).\r\n\r\n---\r\n\r\nCoded by [Estanislau Trepat (etrepat)](http://etrepat.com). I'm also\r\n[@etrepat](http://twitter.com/etrepat) on twitter.\r\n","google":"","note":"Don't delete this file! It's used internally to help with page regeneration."}